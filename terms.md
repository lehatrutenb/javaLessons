# Типы связей классов
## Композиция
#### внутренний класс создаётся в конструкторе второго

```java
public class Parent {
    private Child child;

    public Parent(chParamsT chParams) {
        this.child = new Child(chParams);
    }
}
```

## Аггрегация
#### внутренний класс передаётся в конструктор второго

```java
public class Parent {
    private Child child;

    public Parent(Child child) {
        this.child = child;
    }
}
```

## Ассоциация
#### внутренний класс имеет getter, setter внутри второго

```java
public class Parent {
    @Getter
    @Setter
    private Child child;

    public Parent() {
    }
}
```

Разница в том, что хотим указывать время и обязательность существования внутреннего класса

# OOП

## Инкапсуляция
#### Хотим контролировать доступ к полям класса чтобы не думать при их изменении извне о внутренней логике класса
будем использовать модификаторы доступа:
* для классов:
    + public - виден всем
    + default - виден только внутри пакета

* для аттрибутов и методов:
    + public - виден всем
    + default - виден только внутри пакета
    + protected - виден только внутри пакета и подклассах
    + private - виден только внутри основного класса

```java
public class ClassPublic {
    public int x1;
    int x2;
    protected int x3;
    private int x3;
}

class ClassDefault {
}
```

## Полиморфизм
#### Хотим уметь идентично работать с объектами разных типов, имеющих идентичные сигнатуры функций, но разные реализаци
давайте использовать интерфейсы/абстрактные классы/наследование(для логически родственных) чтобы этого добиться

## Наследование
#### У нас есть класс реализующий свою функциональность, хотим практически такой же, но для других actor-ов + не хотим копипастить тк осложняет дебаг,читаемость,поддержку...
давайте создадим новый класс наследованным от изначального, который частично передаст ему свои методы/аттрибуты

## ООП
#### У нас есть много программистов разных уровней и разных возможностей, давайте договоримся о минимальных идеях при написании кода, чтобы между людьми он был схож/понятен - наследование, полиморфизм, инкапсуляцию

# Принципы разработки

## YAGNI - you aren't gonna need it
#### давайте не будем сохранять в кодовой базе неиспользуемый код + не будем писать тот, что пригодится когда-то в будущем
чтобы этот принцип был адекватным лучше иметь ввиду далёкое будущее, где мы пишем лишние аттрибуты/методы более уникальными и не уверены в их полезности в других конфигурациях

## DRY - don't repeat yourself
#### давайте не будем переписывать то, что уже написано в нашей кодовой базе + не будем использовать практически идентичный код дважды
нужно аккуратно пользоваться этой идеей, тк это может породить лишние связи между модулями - но теоретически хорошо, что не надо будет тестировать дважды/исправлять дважды/читать дважды/...

## KISS - keep it simple, stupid
#### давайте не будем писать сложный код/сложную структуру кода, если этого не требуется для решения задачи - простые системы работают быстрее и надёжнее
я бы изменил и сократил до пишите код, который легко поймут другие, пока это возможно

## BDUF - big design up front
#### давайте планировать, заранее обильно обсуждать архитектуру, возможные трудности, а потом писать


## Бритва Оккама
#### давайте не создавать сущности заранее, без необходимости

## SOLID
### S - single responsibility
#### с классом должен работать только 1 actor = у класса есть ровно 1 причина для изменения
у actor-ов будут меняться требования к классу и мы захотим что-то поправить - но если их много, то сложно и долго аккуратно учитывать и не задевать остальные контракты

### L - liskov substitution
#### ребёнок должен идентично выполнять функционал родителя
хотим гарантию, что родителя везде можно заменить на ребёнка - в реальных системах при соблюдении вытекают сложности по типу программирования по контракту (проверки на тип класса)

### I - interface segregation
#### толстые интерфейсы хотим разделить на более тонкие
не хотим допускать ситуацию когда объекты удовлетворяют интерфейсу, но часть методов возвращает ошибку (unimplemented) - но всё-ещё хотим объединять эти объекты под общий тип - давайте сделаем иерархию интерфейсов

### D - dependency inversion
#### модули верхнего уровня не должны зависить от модулей нижнего
пусть оба уровня будут зависить от интерфейса, а также этот интерфейс должен быть объявлен в родительском модуле, тк иначе родительский модуль всё-ещё будет зависеть от нижнего

### O - open/closed principle
#### для расширению функциональности класса хотим не менять сам класс, а менять интерфейсы и объекты которые он использует
S+D


